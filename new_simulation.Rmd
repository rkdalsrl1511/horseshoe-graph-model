---
title: "New_simulation"
output: github_document
date: "2024-04-15"
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

```{r, include=FALSE}
library(tidyverse)
library(MASS)
library(tictoc)
library(GIGrvg)
library(Rcpp)
```

```{r, include=FALSE}
simulate_sparse_matrix <- function(pi, p) {
  
  if (abs(pi) > 1 | p < 5) {
    stop("0<=pi<=1, p >= 5를 입력하라.")
  }
  result_L <- matrix(0, nrow = p, ncol = p)
  n_nonzero <- ceiling(pi * p * (p-1) / 2)
  graph_list <- list()
  k <- 1
  for (i in 2:p) {
    for (j in 1:(i-1)) {
      graph_list[[k]] <- c(j, i)
      k <- k + 1
    }
  }
  index_nonzero <- sample(graph_list, size = n_nonzero)
  
  # diagonal components
  diag(result_L) <- 1
  
  # non diagonal components
  for (i in 1:length(index_nonzero)) {
    temp <- index_nonzero[[i]]
    u <- runif(1, -0.5, 0.5)
    result_L[temp[1], temp[2]] <- u
  }
  
  A <- t(result_L) %*% result_L
  
}

concentration_sssl <- function(Y, burn = 1000, iter = 5000, pi, lambda = 1, 
                               v0 = 0.02, h = 50) {
  
  N <- nrow(Y)
  p <- ncol(Y)
  S <- t(Y) %*% Y
  v1 <- h * v0
  V <- matrix(v1, nrow = p, ncol = p)
  diag(V) <- 0
  estimate_Omega <- matrix(0, nrow = p, ncol = p)
  estimate_Sigma <- S / N
  Omega_hat <- matrix(0, nrow = p, ncol = p)
  Sigma_hat <- matrix(0, nrow = p, ncol = p)
  concentraion_graph <- matrix(0, nrow = p, ncol = p)
  OmegaSamples <- array(0, dim = c(p, p, iter + burn))
  SigmaSamples <- array(0, dim = c(p, p, iter + burn))
  VSamples <- array(0, dim = c(p, p, iter + burn))
  
  # sampling start
  for (i in 1:(iter + burn)) {
    if (i %% 500 == 0) {
      cat("iter : ", i, "\n")
    }
    # update Omega
    for (j in 1:p) {
      # inverse omega11 matrix
      sig11 <- estimate_Sigma[-j, -j]
      sig12 <- estimate_Sigma[-j, j]
      sig22 <- estimate_Sigma[j, j]
      v12 <- V[-j, j]^2
      inv_omega11 <- sig11 - sig12 %*% t(sig12) / sig22
      
      # u sampling
      inv_C <- (S[j, j] + lambda) * inv_omega11 + diag(v12^(-1))
      C_chol <- chol(inv_C)
      #x <- solve(C_chol, S[-j, j])
      x <- solve(t(C_chol), S[-j, j])
      mu <- -solve(C_chol, x)
      f <- rnorm(p-1, mean = 0, sd = 1)
      f_star <- solve(C_chol, f)
      u <- mu + f_star
      
      # v sampling
      v <- rgamma(1, shape = N/2 + 1, rate = (S[j, j] + lambda)/2)
      
      # omega update
      estimate_Omega[-j, j] <- u
      estimate_Omega[j, -j] <- u
      estimate_Omega[j, j] <- v + t(u) %*% inv_omega11 %*% u
      
      # sigma update
      z <- inv_omega11 %*% u
      estimate_Sigma[-j, -j] <- inv_omega11 + z %*% t(z) / v
      estimate_Sigma[-j, j] <- -z/v
      estimate_Sigma[j, -j] <- -z/v
      estimate_Sigma[j, j] <- 1/v
      
      # V matrix update
      #prob_v <- pi*dnorm(u, 0, v1)/(pi*dnorm(u, 0, v1)+(1-pi)*dnorm(u, 0, v0))
      #v_star <- ifelse(runif(p-1, 0, 1) < prob_v, v1, v0)
      #V[-j, j] <- v_star
      #V[j, -j] <- v_star
      # matlab에 구현된 방법
      w1 <- -log(v0) - (0.5*u^2)/(v0^2) + log(1 - pi)
      w2 <- -log(v1) - (0.5*u^2)/(v1^2) + log(pi)
      w_max <- ifelse(w1 >= w2, w1, w2)
      w <- exp(w2 - w_max) / (exp(w1 - w_max) + exp(w2 - w_max))
      v_star <- ifelse(runif(p-1, 0, 1) < w, v1, v0)
      V[-j, j] <- v_star
      V[j, -j] <- v_star
    }
    OmegaSamples[, , i] <- estimate_Omega
    SigmaSamples[, , i] <- estimate_Sigma
    VSamples[, , i] <- V
    if (i > burn) {
      Omega_hat <- Omega_hat + estimate_Omega
      Sigma_hat <- Sigma_hat + estimate_Sigma
      concentraion_graph <- concentraion_graph + V
    }
  }
  
  model_info <- list(Y = Y, burn = burn, iter = iter, pi = pi, lambda = lambda, 
                     v0 = v0, v1 = v1)
  
  Omega_hat <- Omega_hat/iter
  Sigma_hat <- Sigma_hat/iter
  concentraion_graph <- ifelse(concentraion_graph/iter > (v0 + v1)/2, 1, 0)
  
  result <- list(info = model_info, OmegaSamples = OmegaSamples, 
                 SigmaSamples = SigmaSamples, VSamples = VSamples, 
                 OmegaHat = Omega_hat, SigmaHat = Sigma_hat,
                 Graph = concentraion_graph)
  
}

rejection_src <- "
#include <Rcpp.h>
using namespace Rcpp;

// [[Rcpp::export]]
NumericVector rejection_sampler(NumericVector eps, double a, double b){
  int p = eps.length();
  NumericVector a_eps = a/eps;
  NumericVector i_eps = 1/eps;
  NumericVector b_eps = b/eps;
  NumericVector A = a + log(1 + a_eps);
  NumericVector I = 1 + log(1 + i_eps);
  NumericVector B = b + log(1 + b_eps);
  NumericVector lambda2 = (I - A) / (i_eps - a_eps);
  NumericVector lambda3 = (B - I) / (b_eps - i_eps);
  NumericMatrix total_prob (p, 3);
  total_prob(_, 0) = log(1+a_eps);
  total_prob(_, 1) = total_prob(_, 0) + (1/lambda2) * exp(-A) * (1 - exp(-(I-A)));
  total_prob(_, 2) = total_prob(_, 1) + (1/lambda3) * exp(-I) * (1 - exp(-(B-I)));
  NumericVector total_volume = total_prob(_, 2) + (i_eps) * exp(-B);
  total_prob(_, 0) = total_prob(_, 0)/total_volume;
  total_prob(_, 1) = total_prob(_, 1)/total_volume;
  total_prob(_, 2) = total_prob(_, 2)/total_volume;
  NumericVector eta(p);
  for(int i=0; i<p; ++i){
    if(eps[i] > 1){
      NumericVector v = Rcpp::runif(1, 0, 1);
      double z = -log(1-v[0])/eps[i];
      NumericVector u = Rcpp::runif(1, 0, 1);
      if(u[0] < (1/(1+z))){
        eta[i] = z;
      } else{
        --i;
      }
    } else {
      NumericVector u = Rcpp::runif(1, 0, 1);
      NumericVector u_z = Rcpp::runif(1, 0, 1);
      double z;
      double fl;
      if(u[0] < total_prob(i, 0)){
        z = exp(u_z[0] * log(1 + a_eps[i]))-1;
        fl = log(1 + z);
      } else if(u[0] < total_prob(i, 1)){
        z = a_eps[i] - log(1 - u_z[0] + u_z[0]*exp(-(I[i]-A[i])))/lambda2[i];
        fl = A[i] + lambda2[i] * (z - a_eps[i]);
      } else if(u[0] < total_prob(i, 2)){
        z = i_eps[i] - log(1 - u_z[0] + u_z[0]*exp(-(B[i]-I[i])))/lambda3[i];
        fl = I[i] + lambda3[i] * (z - b_eps[i]);
      } else{
        z = b_eps[i] - log(1 - u_z[0])/eps[i];
        fl = B[i] + eps[i] * (z - b_eps[i]);
      }
      double f = eps[i] * z + log(1 + z);
      u = Rcpp::runif(1, 0, 1);
      if(u[0] < exp(-(f - fl))){
        eta[i] = z;
      } else{
        --i;
      }
    }
  }
  return eta;
}
"
sourceCpp(code = rejection_src)

concentration_horseshoe <- function(Y, burn = 1000, iter = 5000, lambda = 1,
                                    approximate = FALSE, fixed_threshold = 0,
                                    auto.threshold = FALSE, t = 10, 
                                    adapt_p0 = 0, adapt_p1 = -4.6*10^(-4)) {
  N <- nrow(Y)
  p <- ncol(Y)
  S <- t(Y) %*% Y
  xi <- 1
  eta <- matrix(1, nrow = p, ncol = p)
  diag(eta) <- 0
  estimate_Omega <- matrix(0, nrow = p, ncol = p)
  estimate_Sigma <- S / N
  m_eff <- rep(p-1, p)
  if (fixed_threshold == 0) {
    fixed_threshold <- 1/(p^2)
  }
  Omega_hat <- matrix(0, nrow = p, ncol = p)
  Sigma_hat <- matrix(0, nrow = p, ncol = p)
  Eta_hat <- matrix(0, nrow = p, ncol = p)
  concentration_graph <- matrix(0, nrow = p, ncol = p)
  OmegaSamples <- array(0, dim = c(p, p, iter + burn))
  SigmaSamples <- array(0, dim = c(p, p, iter + burn))
  XiSamples <- rep(0, iter + burn)
  EtaSamples <- array(0, dim = c(p, p, iter + burn))
  ActiveMatrixSamples <- array(0, dim = c(p, p, iter + burn))
  
  # sampling start
  for (i in 1:(iter + burn)) {
    if (i %% 500 == 0) {
      cat("iter : ", i, "\n")
    }
    # active_matrix
    active_matrix <- matrix(0, nrow = p, ncol = p)
    # update m_eff
    if (auto.threshold == TRUE) {
      if (i %% t == 0) {
          for (j in 1:p) {
            u_i <- stats::runif(1, 0, 1)
            p_i <- exp(adapt_p0 + adapt_p1 * i)
            if (u_i < p_i) {
            m_eff[j] <- sum(1/((S[j, j]+lambda)^(-1) * xi * eta[-j, j] *
                                 diag(estimate_Omega[-j, -j]) + 1))
            }
          }
      }
    }
    # update Omega
    for (j in 1:p) {
      v12 <- xi * eta[, j]
      if (approximate == TRUE) {
        if (auto.threshold == TRUE) {
          threshold <- sort(eta[-j, j])[ceiling(m_eff[j])]
          active_matrix[-j, j] <- ifelse(eta[-j, j] <= threshold, 1, active_matrix[-j, j])
          active_matrix[j, -j] <- active_matrix[-j, j]
          k <- which(active_matrix[, j] == 1)
          h <- which(active_matrix[-j, j] == 1)
        } else {
          active_matrix[-j, j] <- ifelse(v12[-j] < 1/fixed_threshold, 1, 
                                         active_matrix[-j, j])
          active_matrix[j, -j] <- active_matrix[-j, j]
          k <- which(active_matrix[, j] == 1)
          h <- which(active_matrix[-j, j] == 1)
        }
      } else {
        k <- c(1:p)[-j]
        h <- 1:(p-1)
      }
      active_num <- length(k)
      sig11 <- estimate_Sigma[-j, -j]
      sig12 <- estimate_Sigma[-j, j]
      sig22 <- estimate_Sigma[j, j]
      inv_omega11 <- sig11 - sig12 %*% t(sig12) / sig22
      # u sampling
      if(active_num != 0) {
        inv_C <- (S[j, j] + lambda) * inv_omega11[h, h] + 
          diag(v12[k], nrow = active_num, ncol = active_num)
        inv_C <- (inv_C + t(inv_C))/2
        C_chol <- chol(inv_C)
        x <- solve(t(C_chol), S[k, j])
        mu <- -solve(C_chol, x)
        f <- rnorm(active_num, mean = 0, sd = 1)
        f_star <- solve(C_chol, f)
        u <- mu + f_star
        estimate_Omega[k, j] <- u
        estimate_Omega[j, k] <- u
        # inactive u sampling
        if (p-active_num-1 != 0) {
          n_f <- rnorm(p-active_num-1, 0, 1)
          n_u <- -(S[-c(k, j), j]/v12[-c(k, j)]) + n_f/sqrt(v12[-c(k, j)])
          estimate_Omega[-c(k, j), j] <- n_u
          estimate_Omega[j, -c(k, j)] <- n_u
        }
      } else { 
        # 모든 성분이 inactive인 경우
        f <- rnorm(p-1, 0, 1)
        u <- -(S[-j, j]/v12[-j]) + f/sqrt(v12[-j])
        estimate_Omega[-j, j] <- u
        estimate_Omega[j, -j] <- u
      }
      u_star <- estimate_Omega[-j, j]
      # v sampling
      v <- rgamma(1, shape = N/2 + 1, rate = (S[j, j] + lambda)/2)
      estimate_Omega[j, j] <- v + t(u_star) %*% inv_omega11 %*% u_star
      # sigma update
      z <- inv_omega11 %*% u_star
      estimate_Sigma[-j, -j] <- inv_omega11 + z %*% t(z) / v
      estimate_Sigma[-j, j] <- -z/v
      estimate_Sigma[j, -j] <- -z/v
      estimate_Sigma[j, j] <- 1/v
      
      # eta update
      upsi <- stats::runif(p-1, 0, 1/(1 + eta[-j, j]))
      tempps <- (xi * u_star^2)/2
      ub <- (1 - upsi)/upsi
      Fub <- 1 - exp(-tempps * ub)
      Fub[Fub < (1e-04)] <- 1e-04
      up <- stats::runif(p-1, 0, Fub)
      new_eta <- -log(1 - up)/tempps
      new_eta <- ifelse(new_eta <= 2.220446e-16, 2.220446e-16, new_eta)
      eta[-j, j] <- new_eta
      eta[j, -j] <- new_eta
      
      # eta update : rejection sampler version
      #eps <- (xi * u_star^2)/2
      #new_eta <- rejection_sampler(eps, a = 0.2, b = 10)
      #new_eta <- ifelse(new_eta <= 2.220446e-16, 2.220446e-16, new_eta)
      #eta[-j, j] <- new_eta
      #eta[j, -j] <- new_eta
    }
    
    # xi update : halfCauchy
    tempt <- sum(estimate_Omega^2 * eta)/4
    utau <- stats::runif(1, 0, 1/(1 + xi))
    ubt <- (1 - utau)/utau
    Fubt <- stats::pgamma(ubt, (p*(p-1)+2)/4, scale = 1/tempt)
    Fubt <- max(Fubt, 1e-08)
    ut <- stats::runif(1, 0, Fubt)
    xi <- stats::qgamma(ut, (p*(p-1)+2)/4, scale = 1/tempt)
    
    #xi update : fixed
      #xi <- 100
    
    # xi update : Metropolis algorithm
    #tempt <- sum(estimate_Omega^2 * eta)/4
    #new_xi <- exp(stats::rnorm(1, mean = log(xi), sd = 0.8))
    #dxi <- stats::dgamma(c(xi, new_xi), (p*(p-1)+2)/4, scale = 1/tempt)
    #dxi <- ifelse(dxi <= 2.220446e-16, 2.220446e-16, dxi)
    #accept_prob <- ((1+xi)*new_xi*dxi[2])/((1+new_xi)*xi*dxi[1])
    #if (runif(1, 0, 1) < accept_prob) {
    #  xi <- new_xi
    #}
    
    OmegaSamples[, , i] <- estimate_Omega
    SigmaSamples[, , i] <- estimate_Sigma
    EtaSamples[, , i] <- eta
    XiSamples[i] <- xi
    ActiveMatrixSamples[, , i] <- active_matrix
    if (i > burn) {
      Omega_hat <- Omega_hat + estimate_Omega
      Sigma_hat <- Sigma_hat + estimate_Sigma
      Eta_hat <- Eta_hat + eta
      concentration_graph <- concentration_graph + active_matrix
    }
  }
  
  model_info <- list(Y = Y, burn = burn, iter = iter, pi = pi, lambda = lambda)
  
  Omega_hat <- Omega_hat/iter
  Sigma_hat <- Sigma_hat/iter
  Eta_hat <- Eta_hat/iter
  Xi_hat <- mean(XiSamples[(burn+1):(iter+burn)])
  concentration_graph <- ifelse(concentration_graph/iter > 0.5, 1, 0)
  
  result <- list(info = model_info, OmegaSamples = OmegaSamples, 
                 SigmaSamples = SigmaSamples, EtaSamples = EtaSamples, 
                 XiSamples = XiSamples, 
                 ActiveMatrixSamples = ActiveMatrixSamples, 
                 OmegaHat = Omega_hat, SigmaHat = Sigma_hat, EtaHat = Eta_hat, 
                 XiHat = Xi_hat, Graph = concentration_graph)
}

graph_evaluation <- function(true_graph, pred_graph) {
  TP <- sum((true_graph == 1) & (pred_graph == 1))
  FP <- sum((true_graph == 0) & (pred_graph == 1))
  TN <- sum((true_graph == 0) & (pred_graph == 0))
  FN <- sum((true_graph == 1) & (pred_graph == 0))
  
  MCC <- (TP * TN - FP * FN) / sqrt(TP + FP)
  MCC <- MCC / sqrt(TP + FN)
  MCC <- MCC / sqrt(TN + FP)
  MCC <- MCC / sqrt(TN + FN)
  
  Accuracy <- (TP + TN)/(TP + TN + FP + FN)
  Sensitivity <- TP/(TP + FN)
  Specificity <- TN/(TN + FP)
  Precision <- TP/(TP + FP)
  
  cat("MCC : ", MCC, "\n")
  cat("Accuracy : ", Accuracy, "\n")
  cat("Sensitivity : ", Sensitivity, "\n")
  cat("Specificity : ", Specificity, "\n")
  cat("Precision : ", Precision, "\n")
}
```

# 1. sparsity 강도가 약한 데이터

precision matrix에 대한 시뮬레이션 데이터를 생성하고, 이에 대한 역행렬을
true precision matrix로 설정하였다.

```{r}
N <- 10000
p <- 100
real_pi <- 0.05
sim_data <- simulate_sparse_matrix(real_pi, p)
sim_omega <- round(sim_data, digits = 3)
sim_sigma <- solve(sim_omega)
Y <- mvrnorm(n = N, mu = rep(0, p), Sigma = sim_sigma)
sim_graph <- ifelse(abs(sim_omega) > 0, 1, 0)
diag(sim_graph) <- 0
sum(sim_graph)
```

### 함수 적용 + 경과 시간 체크
```{r}
# sssl
tic()
sssl_model <- concentration_sssl(Y, pi = 2/(p-1), burn = 500, iter = 500, h = 50)
toc()

# horseshoe
tic()
horseshoe_model <- concentration_horseshoe(Y = Y, burn = 500, iter = 500, 
                                           approximate = FALSE)
toc()

# approximate horseshoe with fixed threshold
tic()
fixed_approx_horseshoe_model <- concentration_horseshoe(Y = Y, burn = 500, 
                                                        iter = 500,
                                                        fixed_threshold = p^(-2),
                                                        approximate = TRUE)
toc()

# approximate horseshoe with adaptive threshold
tic()
adaptive_approx_horseshoe_model <- concentration_horseshoe(Y = Y, burn = 500,
                                                           iter = 500,
                                                           approximate = TRUE, 
                                                           auto.threshold = TRUE)
toc()
```

### Frobenius norm

```{r}
# sssl
sum((sssl_model$OmegaHat - sim_omega)^2)

# horseshoe
sum((horseshoe_model$OmegaHat - sim_omega)^2)

# approximate horseshoe with fixed threshold
sum((fixed_approx_horseshoe_model$OmegaHat - sim_omega)^2)

# approximate horseshoe with adaptive threshold
sum((adaptive_approx_horseshoe_model$OmegaHat - sim_omega)^2)
```


### MCC measure

```{r}
graph_evaluation(sim_graph, sssl_model$Graph)
graph_evaluation(sim_graph, fixed_approx_horseshoe_model$Graph)
graph_evaluation(sim_graph, adaptive_approx_horseshoe_model$Graph)
```

# 2. sparsity 강도가 강한 데이터

precision matrix에 대한 시뮬레이션 데이터를 생성하고, 이에 대한 역행렬을
true precision matrix로 설정하였다.

```{r}
N <- 10000
p <- 100
real_pi <- 0.01
sim_data <- simulate_sparse_matrix(real_pi, p)
sim_omega <- round(sim_data, digits = 3)
sim_sigma <- solve(sim_omega)
Y <- mvrnorm(n = N, mu = rep(0, p), Sigma = sim_sigma)
sim_graph <- ifelse(abs(sim_omega) > 0, 1, 0)
diag(sim_graph) <- 0
sum(sim_graph)
```

### 함수 적용 + 경과 시간 체크
```{r}
# sssl
tic()
sssl_model <- concentration_sssl(Y, pi = 2/(p-1), burn = 500, iter = 500, h = 50)
toc()

# horseshoe
tic()
horseshoe_model <- concentration_horseshoe(Y = Y, burn = 500, iter = 500, 
                                           approximate = FALSE)
toc()

# approximate horseshoe with fixed threshold
tic()
fixed_approx_horseshoe_model <- concentration_horseshoe(Y = Y, burn = 500, 
                                                        iter = 500,
                                                        fixed_threshold = p^(-2),
                                                        approximate = TRUE)
toc()

# approximate horseshoe with adaptive threshold
tic()
adaptive_approx_horseshoe_model <- concentration_horseshoe(Y = Y, burn = 500,
                                                           iter = 500,
                                                           approximate = TRUE, 
                                                           auto.threshold = TRUE)
toc()
```

### Frobenius norm

```{r}
# sssl
sum((sssl_model$OmegaHat - sim_omega)^2)

# horseshoe
sum((horseshoe_model$OmegaHat - sim_omega)^2)

# approximate horseshoe with fixed threshold
sum((fixed_approx_horseshoe_model$OmegaHat - sim_omega)^2)

# approximate horseshoe with adaptive threshold
sum((adaptive_approx_horseshoe_model$OmegaHat - sim_omega)^2)
```

### MCC measure

```{r}
graph_evaluation(sim_graph, sssl_model$Graph)
graph_evaluation(sim_graph, fixed_approx_horseshoe_model$Graph)
graph_evaluation(sim_graph, adaptive_approx_horseshoe_model$Graph)
```


